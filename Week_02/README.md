# 学习笔记
## 哈希表
 哈希表的插入，查找，添加和删除操作的平均计算复杂度都是O(1)，在最坏的情况下，哈希会产生很多的冲突，会使得其退化成链表的形式。 但是，随着计算机的内存大扩大和哈希函数的不断优化，所有的操作基本上都是O(1)的。哈希表在统计若干元素的个数是有很大 的用途。可以用数组实现，数组的下标可以对应特定的字符或字符串，数组中的值可以表示对应字符或字符串的性质，如频率或个数。 例如，可以用长度为26的数字来构造一个哈希表，数组下标对应着26个英文字母。

## 映射和set
其中的数据类型可以很广泛，既可以是int型，也可以是复合形式的的，map可以保存高维的数据，尤其是可以保存对象和该对象对应 的性质。一个经典的应用就是求数组中的两个数字和等于目标的下标，用map实现哈希表，计算复杂度是O(n)的。 同时，可以用set来实现删除重复元素的目的。

## 二叉搜索树
二叉搜索树是一种非常重要的二叉树，每个节点都有一个数值，父节点中的数值大于左子树上所有的数值，同时也小于右子树 上所有的数值。查找的时间计算复杂度是log(n)的。二叉树的前，中和后序遍历可以用递归的方法解决。一般在面试时，解决 二叉树的遍历都是用递归方法。

## 递归
- 递归需要满足三个条件：
  - 一个问题的解可以分解为几个子问题的解
  - 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
  - 存在递归终止条件。写递归代码最关键的是要写出递推公式，找到终止条件，最后将递推公式和终止条件翻译成代码。
  
- 编写递归代码的关键是只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 在写递归代码的时候，要着重防止堆栈溢出，如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。这个时候我们就要通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度后，就不继续往下递归了，直接返回报错，但是这种做法并不能完全解决问题，因为最大允许的递归深度和当前线程剩余的栈空间大小有关，事先无法计算。 除此之外，递归代码要警惕重复计算。